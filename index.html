<!DOCTYPE html>
<meta charset="utf-8">
<title>MS-1 UNDP </title>
<html>



<style>

</style>

<body>

<div class="box box--one" id="box-one">
    <h1>African Cities</h1>
    <h3>URBAN DEVELOPMENT IN SUBSAHARAN AFRICA</h3>
</div>

<div class="box box--two">
    <div id="wid">As world population continues to grow, an increasing number of people are moving to cities aspiring better living conditions, higher quality education and greater economic opportunities. <br> <br>In 2008, for the first time in human history, half of the worldâ€™s population lived in towns and cities. Africa is currently the least urbanized continent, <br> but its urbanization rate of 3.5 percent per year is the fastest in the world. <br> In 1980, only 28 percent of Africans lived in urban areas. Today, the number of Africans living in cities is 40 percent, and is projected to grow to 50 percent by 2030. As this has immediate social-economic impacts, it is interesting to investigate the relation between urbanization data and inequality trends. Find below a visualization of the urbanization rate, overall and per Gini-category. </div>
</div>
<br>
<br>



    <p> <input type="checkbox" id="myCheckbox">   Compare urbanization over the last 30 urbPerc and before: urban population as % of total before and after 1976 </p>
    <p><label><input type="checkbox" id="checkboxGini" > Sort countries by income inequality trend (based on Gini coefficient)</label></p>
        <svg></svg>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.12.0/d3.min.js"></script>
        <script src="//d3js.org/d3-scale-chromatic.v0.3.min.js"></script>
        <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
        <link rel="stylesheet" type="text/css" href="style.css" >
    <script>

    var dataFile = './maps/data2.csv';


    d3.csv(dataFile, function(error, data){
        var input = {'data': data, 'width': 1000, 'height': 550};
            canvas = setUpSvgCanvas(input);

        drawBars(input, canvas);
        console.log(data)
    });



    function drawBars(input, canvas) {

        var params = {'input': input, 'canvas': canvas};
        initialize(params);
        update(params);
        update1(params);
    }


    function initialize(params) {

        // unpacking params
        var canvas = params.canvas,
            input = params.input;

        // unpacking canvas
        var svg = canvas.svg,
            margin = canvas.margin,
            width = params.width = canvas.width,
            height = params.height = canvas.height;

        // processing Data and extracting years and urbPerc
        var formattedData = formatData(input.data),
            blockData = params.blockData = formattedData.blockData,
            years = params.years = formattedData.years,
            urbPerc = params.urbPerc = formattedData.urbPerc;


        // initialize color
        var color = setUpColors().domain(urbPerc);

        // initialize scales and axis
        var scales = initializeScales(width, height),
            x = scales.x,
            y = params.y = scales.y;

        x.domain(years);
        y.domain([0, d3.max(blockData, function(d) { return d.y1; })]);

        initializeAxis(svg, x, y, height, width);

        // initialize bars
        var bar = params.bar = svg.selectAll('.bar')
            .data(blockData)
            .enter().append('g')
            .attr('class', 'bar');

        bar.append('rect')
            .attr('x', function(d) { return x(d.x);})
            .attr('y', function(d) {return y(0);})
            .attr('width', x.bandwidth())
            .attr('height', 0)
            .attr('fill', function(d){ return color(d.countries);});

        // heights is a dictionary to store bar height by countries
        // this hierarchy is important for animation purposes
        // each bar above the chosen bar must collapse to the top of the
        // selected bar, this function defines this top
        params.heights = setUpHeights(urbPerc, blockData);

        // defining max of each bin to convert later to percentage
        params.maxPerBin = setUpMax(urbPerc, blockData);


        // variable to store chosen countries when bar is clicked
        var chosen = params.chosen = {
            countries: null
        };

        // initialize legend
        var legend = params.legend = svg.selectAll('.legend')
            .data(urbPerc)
            .enter().append('g')
            .attr('class', 'legend');

        legend.append('rect')
            // .attr('x', width + margin.right - 18)
            // .attr('y', function(d, i) {return 20 * (urbPerc.length - 80 - i);})
            .attr('x', width + margin.right - 18)
            .attr('y', height - 10)
            .attr('height', 18)
            .attr('width', 18)
            .attr('fill', function(d){ return color(d);})
            .on('click', function(d){
                chosen.countries = chosen.countries === d ? null : d;
                update(params);
            });

        // text for legend:
        legend.append('text')
            .attr('x', width + margin.right - 25)
            .attr('y', function(d, i) { return 20 * (urbPerc.length - 1 - i) ;})
            .text(function(d) {return d;})
            .attr('dy', '.95em')
            .style('text-anchor', 'end');

        // text for y-axis
        svg.append('text')
            .attr("class", "descrAxisY")
            .attr("transform", "rotate(-90)")
            .attr("y", 6)
            .attr("dy", "-3em")
            .style("text-anchor", "end")
            .text("Urban population as % of total");


        // initialize checkbox options
        d3.select("#myCheckbox").on("change",function(){update(params);});
        d3.select("#checkboxGini").on("change",function(){update1(params);});

        params.view = false;

    }

    function update(params){

        // retrieving params to avoid putting params.x everywhere
        var svg = params.canvas.svg,
            margin = params.canvas.margin,
            y = params.y,
            blockData = params.blockData,
            heights = params.heights,
            chosen = params.chosen,
            width = params.width,
            height = params.height,
            bar = params.bar,
            urbPerc = params.urbPerc,
            years = params.years,
            legend = params.legend,
            maxPerBin = params.maxPerBin,
            view = params.view;

        var transDuration = 1030;

        // re-scaling data if view is changed to percentage
        // and re-scaling back if normal view is selected
        var newView = d3.select("#myCheckbox").property("checked");

        if(newView){
            if(view !== newView){
                blockData.forEach(function (d){
                    d.y0 /= maxPerBin[d.x];
                    d.y1 /= maxPerBin[d.x];
                    d.height /= maxPerBin[d.x];
                });
                heights = setUpHeights(urbPerc, blockData);

                //update y-axis description
                d3.select(".descrAxisY")
                    .text("Total urban population since 1976");
            }
        }
        else{
            if(view !== newView){
                blockData.forEach(function (d){
                    d.y0 *= maxPerBin[d.x];
                    d.y1 *= maxPerBin[d.x];
                    d.height *= maxPerBin[d.x];
                });
                heights = setUpHeights(urbPerc, blockData);
            }
        }
        params.view = newView;


        // update Y axis
        if(chosen.countries == null){
            y.domain([0, d3.max(blockData, function(d) { return d.y1; })]);
        }
        else{
            y.domain([0, d3.max(heights[chosen.countries])]);
        }

        if(newView){
            y.domain([0, 1]);
        }

        var axisY = d3.axisLeft(y)
            .tickSize(-width)
            .tickFormat(function(d) { return d + "%"; });
        // .tickFormat(d3.format(".0%"));

        if(newView){
            axisY.tickFormat(d3.format(".0%"));
        }

        svg.selectAll('.axisY')
            .transition()
            .duration(transDuration)
            .call(axisY);


        // update legend
        legend.selectAll('rect')
            .transition()
            .duration(transDuration)
            .attr('height', function(d) {return choice(chosen.countries, d, 18, 18, 0);})
            .attr('y', function(d) {
                var i = urbPerc.indexOf(d);
                if (i > urbPerc.indexOf(chosen.countries)){
                    return choice(chosen.countries, d, 20 * (urbPerc.length - 1 - i) , 0, 0);
                }
                else {
                    return choice(chosen.countries, d, 20 * (urbPerc.length - 1 - i) , 0,  18);
                }
            });
        legend.selectAll('text')
            .transition()
            .duration(transDuration)
            .attr('y', function(d) {
                var i = urbPerc.indexOf(d);
                if (i > urbPerc.indexOf(chosen.countries)){
                    return choice(chosen.countries, d, 20 * (urbPerc.length - 1 - i) , 0, 0);
                }
                else {
                    return choice(chosen.countries, d, 20 * (urbPerc.length - 1 - i) , 0,  1);
                }
            })
            .style('font-size' ,function(d, i) {return choice(chosen.countries, d, '16px', '16px', '0px');})
            .attr('x', function(d) {return choice(chosen.countries, d,
                width + margin.right - 25,
                width + margin.right - 25,
                width + margin.right - 25 - this.getComputedTextLength()/2);});



        // update bars
        bar.selectAll('rect')
            .on('click', function(d){
                chosen.countries = chosen.countries === d.countries ? null : d.countries;
                update(params);
            })
            .transition()
            .duration(transDuration)
            .attr('y', function(d) {
                return choice(chosen.countries, d.countries,
                    y(d.y1),
                    y(d.height),
                    myHeight(chosen, d, urbPerc, years, y, heights));})
            .attr('height', function(d) {
                return choice(chosen.countries, d.countries,
                    height - y(d.height),
                    height - y(d.height),
                    0);});
    } // end of first update


    function update1(params){

        // retrieving params to avoid putting params.x everywhere
        var svg = params.canvas.svg,
            margin = params.canvas.margin,
            y = params.y,
            blockData = params.blockData,
            heights = params.heights,
            chosen = params.chosen,
            width = params.width,
            height = params.height,
            bar = params.bar,
            urbPerc = params.urbPerc,
            years = params.years,
            legend = params.legend,
            maxPerBin = params.maxPerBin,
            view = params.view,
            ginis = params.ginis;

        var transDuration = 1030;

        // re-scaling data if view is changed to percentage
        // and re-scaling back if normal view is selected
        var newView = d3.select("#checkboxGini").property("checked");

        if(newView) {

            if (view !== newView) { //checked

                function showGini(d) {
                    console.log(d.gini)
                };

                showGini();


                // // Sort totals in descending order
                // ginis.sort(function (a, b) {
                //     return d3.ascending(a.key, b.key)
                // });
                //
                // x.domain(urbPerc.map(function (d) {
                //     return d.key;
                // }));
                //
                // svg.selectAll(bar)
                //     .transition()
                //     .duration(500)
                //     .attr("x", function (d, i) {
                //         return x(d.key);
                //     });
                //
                // // svg.selectAll(".val-label")
                // //     .transition()
                // //     .duration(500)
                // //     .attr("x", function(d, i) {
                // //         return x(d.key) + x.bandwidth() / 2;
                // //     });
                // //
                // // svg.selectAll(".bar-label")
                // //     .transition()
                // //     .duration(500)
                // //     .attr("transform", function(d, i) {
                // //         return "translate(" + (x(d.key) + x.bandwidth() / 2 - 8) + "," + (height + 15) + ")" + " rotate(45)"
                // //     });



            }

            else { //unchecked
                if (view !== newView) {

                    console.log("unsort")

                }
            }
        }
        params.view = newView;


        // // update Y axis
        // if(chosen.countries == null){
        //     y.domain([0, d3.max(blockData, function(d) { return d.y1; })]);
        // }
        // else{
        //     y.domain([0, d3.max(heights[chosen.countries])]);
        // }
        //
        // if(newView){
        //     y.domain([0, 1]);
        // }
        //
        // var axisY = d3.axisLeft(y)
        //     .tickSize(-width)
        //     .tickFormat(function(d) { return d + "%"; });
        //     // .tickFormat(d3.format(".0%"));
        //
        // if(newView){
        //     axisY.tickFormat(d3.format(".0%"));
        // }
        //
        // svg.selectAll('.axisY')
        //     .transition()
        //     .duration(transDuration)
        //     .call(axisY);
        //
        //
        // // update legend
        // legend.selectAll('rect')
        //     .transition()
        //     .duration(transDuration)
        //     .attr('height', function(d) {return choice(chosen.countries, d, 18, 18, 0);})
        //     .attr('y', function(d) {
        //         var i = urbPerc.indexOf(d);
        //         if (i > urbPerc.indexOf(chosen.countries)){
        //             return choice(chosen.countries, d, 20 * (urbPerc.length - 1 - i) , 0, 0);
        //         }
        //         else {
        //             return choice(chosen.countries, d, 20 * (urbPerc.length - 1 - i) , 0,  18);
        //         }
        //     });
        // legend.selectAll('text')
        //     .transition()
        //     .duration(transDuration)
        //     .attr('y', function(d) {
        //         var i = urbPerc.indexOf(d);
        //         if (i > urbPerc.indexOf(chosen.countries)){
        //             return choice(chosen.countries, d, 20 * (urbPerc.length - 1 - i) , 0, 0);
        //         }
        //         else {
        //             return choice(chosen.countries, d, 20 * (urbPerc.length - 1 - i) , 0,  1);
        //         }
        //     })
        //     .style('font-size' ,function(d, i) {return choice(chosen.countries, d, '16px', '16px', '0px');})
        //     .attr('x', function(d) {return choice(chosen.countries, d,
        //         width + margin.right - 25,
        //         width + margin.right - 25,
        //         width + margin.right - 25 - this.getComputedTextLength()/2);});
        //
        //
        //
        // // update bars
        // bar.selectAll('rect')
        //     .on('click', function(d){
        //         chosen.countries = chosen.countries === d.countries ? null : d.countries;
        //         update(params);
        //     })
        //     .transition()
        //     .duration(transDuration)
        //     .attr('y', function(d) {
        //         return choice(chosen.countries, d.countries,
        //             y(d.y1),
        //             y(d.height),
        //             myHeight(chosen, d, urbPerc, years, y, heights));})
        //     .attr('height', function(d) {
        //         return choice(chosen.countries, d.countries,
        //             height - y(d.height),
        //             height - y(d.height),
        //             0);});
    } // end of second update





    // heights is a dictionary to store bar height by countries
    // this hierarchy is important for animation purposes
    function setUpHeights(urbPerc, blockData) {
        var heights = {};
        urbPerc.forEach(function(countries) {
            var countriesVec = [];
            blockData.filter(function (d){ return d.countries === countries;}).forEach(function(d) {
                countriesVec.push(d.height);
            });
            heights[countries] = countriesVec;
        });
        return heights;
    }

    // getting the max value of each bin, to convert back and forth to percentage
    function setUpMax(urbPerc, blockData){
        var lastcountriesElements = blockData.filter(function(d){return d.countries === urbPerc[urbPerc.length - 1]});
        var maxDict = {};
        lastcountriesElements.forEach(function(d) {
            maxDict[d.x] = d.y1;
        });
        return maxDict;
    }

    // custom function to provide correct animation effect
    // bars should fade into the top of the remaining bar
    function myHeight(chosen, d, urbPerc, years, y, heights){
        if(chosen.countries == null){
            return 0;
        }
        if(urbPerc.indexOf(chosen.countries) > urbPerc.indexOf(d.countries)){
            return y(0);
        }
        else {
            return y(heights[chosen.countries][years.indexOf(d.x)]);
        }
    }


    // handy function to play the update game with the bars and legend
    function choice(variable, target, nullCase, targetCase, notTargetCase){
        switch(variable) {
            case null:
                return nullCase;
            case target:
                return targetCase;
            default:
                return notTargetCase;
        }
    }


    function initializeScales(width, height){
        var x = d3.scaleBand()
            .rangeRound([0, width])
            .padding(0.5);

        var y = d3.scaleLinear()
            .range([height, 0]);

        return {
            x: x,
            y: y
        };
    }


    function initializeAxis(svg, x, y, height, width){

        var yAxis = d3.axisLeft(y)
                    .tickFormat(d3.format(".0%"));

        svg.append('g')
            .attr('class', 'axisY')
            .call(yAxis);

        svg.append('g')
            .attr('class', 'axisX')
            .attr('transform', 'translate(0,' + height + ')')
            .call(d3.axisBottom(x))
            .selectAll('text')
            .style('text-anchor', 'start')
            .attr('transform', 'rotate(45 -10 10)');

    }


    function setUpSvgCanvas(input) {
        // Set up the svg canvas
        var margin = {top: 20, right: 80, bottom: 100, left: 80},
            width = input.width - margin.left -margin.right,
            height = input.height - margin.top -margin.bottom;

        var svg = d3.select('svg')
            .attr('width', width + margin.left + margin.right )
            .attr('height', height + margin.top +margin.bottom )
            .append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

        return {
            svg: svg,
            margin: margin,
            width: width,
            height: height
        };
    }


    function setUpColors() {
        return d3.scaleOrdinal(d3.schemeSet1);
    }


    // formatting Data to a more d3-friendly format
    // extracting countries and urbPerc
    function formatData(data) {

        var urbPerc = d3.keys(data[0]).filter(function (key) {
            return key !== 'countryName' && key !== 'gini';
        });

        var ginis = d3.keys(data[0]).filter(function (key) {
            return key === 'gini';
        });


        var years = [];
        var blockData = [];

        for (var i = 0; i < data.length; i++) {
            var y = 0;
            years.push(data[i].countryName);
            for (var j = 0; j < urbPerc.length; j++) {
                var height = parseFloat(data[i][urbPerc[j]]);
                var block =
                    {
                        'y0': parseFloat(y),
                        'y1': parseFloat(y) + parseFloat(height),
                        'height': height,
                        'x': data[i].countryName,
                        'countries': urbPerc[j]
                    };
                y += parseFloat(data[i][urbPerc[j]]);
                blockData.push(block);
            }
        }

        var orderedData = [];


        // console.log(ginis);
        // console.log(blockData);

        return {
            blockData: blockData,
            years: years,
            urbPerc: urbPerc,
            ginis: ginis
        };


    }






        </script>
    </body>
</html>
